component rpi_spi_cpld """Hardware driver and firmware for the RPi-CNC-HAT, for use with stepper machines.and RaspberryPi SPI .""";

description """
rpi_spi_cpld is a LinuxCNC software driver and associated firmware that allow the RPi-CNC-HAT board to be used to control a stepper-based CNC machine.

The driver has 4 step+direction channels, 14 dedicated digital outputs, and 16
dedicated digital inputs.

.SS Step generators
The step generator takes a position input and output.

The step waveform includes step length/space and direction hold/setup time.
Step length and direction setup/hold time is enforced in the FPGA.  Step space
is enforced by a velocity cap in the driver.

\\fI(all the following numbers are subject to change)\\fR
In \\fIspeedrange=0\\fR, the maximum step rate is 312.5kHz.  For position
feedback to be accurate, the maximum step rate is 512 pulses per servo cycle
(so a 1kHz servo cycle does not impose any additional limitation).  The maximum
step rate may be lowered by the step length and space parameters, which are
rounded up to the nearest multiple of 1600ns.

In successive speedranges the maximum step rate is divided in half, as is the
maximum steps per servo cycle, and the minimum nonzero step rate.

.SS Digital I/O
The digital output pins conform to the `canonical digital output' interface
described in the HAL manual.

The digital input pins conform to the `canonical digital input' interface
described in the HAL manual.
""";

pin in float stepgen.#.position-cmd[4];
pin out float stepgen.#.velocity-fb[4];
pin out float stepgen.#.position-fb[4];
pin out s32 stepgen.#.counts[4];
pin in bit stepgen.#.enable[4];
pin in bit stepgen.#.reset[4] "When TRUE, reset position-fb to 0";
param rw float stepgen.#.scale[4] = 1.0;
param rw float stepgen.#.maxvel[4] = 0;
param rw bit stepgen.step_polarity;

param rw u32 stepgen.steplen "Step length in ns.";
param rw u32 stepgen.stepspace "Step space in ns";
param rw u32 stepgen.dirtime "Dir hold/setup in ns.  Refer to the pdf documentation for a diagram of what these timings mean.";

pin in bit dout.##[14]
"""dout.\\fIMM\\fR corresponds to the pin labeled
OUT\\fIM\\fR on the pinout diagram.""";
param rw bit dout.##-invert[14]
"If TRUE, the output on the corresponding \\fBdout.\\fIMM\\fR is inverted.";

pin out bit din.##[16];
pin out bit din.##_not[16]
"""din.\\fIMM\\fR corresponds to the pin labeled
IN\\fIM\\fR on the pinout diagram.""";

param rw u32 spindle.rpm "Spindle rpm";
//param rw u32 servo.pwm "Set pwm 1-2ms (0-255)";
param rw u32 pwm.out "Set pwm 0-255";

param rw u32 communication_error """Incremented each time 
pluto-step.read detects an error code in the EPP status register.  While
this register is nonzero, new values are not being written to the Pluto-P
board, and the status of digital outputs and the PWM duty cycle of the PWM
outputs will remain unchanged.  If the hardware watchdog is enabled, it will
activate shortly after the communication error is detected by LinuxCNC.  To continue
after a communication error, set this parameter back to zero.""";

param rw s32 debug_0;
param rw s32 debug_1;
param rw float debug_2=.5;
param rw float debug_3=2.0
 """Registers that hold debugging information of interest to developers""";

option singleton;
option extra_setup;
option extra_cleanup;
option data internal;
//extra_link_args "lspi.o -lclk.o";

see_also """The \\fIpluto_step\\fR section in the HAL User Manual, which shows the location of each physical pin on the pluto board.""";

function transfer  "transfers data between master and slave devices";
function spitest "test spi transfer (only for developers)";

license "GPL";
author "Matsche & fedor2018";
;;

#include "rtapi.h"
#include "rtapi_bitops.h"
#include "rtapi_app.h"
#include "hal.h"

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>
#include <stdarg.h>
#include <linux/types.h>
#include <linux/spi/spidev.h>

typedef enum {
    UNSUPPORTED,
    RPI,
    RPI_2
} platform_t;


#define SPI_BUFFER_SIZE 20
#define BUFSIZE	(SPI_BUFFER_SIZE/4)

#include "clk.h"

volatile unsigned *gpio, *spi;
int fd;
uint8_t spi_mode;
uint8_t spi_bits;
__u32 spi_speed;
__u16 spi_delay;

static volatile __u32 txBuf[BUFSIZE], rxBuf[BUFSIZE];
static platform_t platform;

//platform_t check_platform(void);

static int speedrange=0;
RTAPI_MP_INT(speedrange, "Speed range 0..3");

#define PLUTO_SPEED_NS (1600)
#define PLUTO_SPEED    (PLUTO_SPEED_NS * 1e-9)
#define PLUTO_FREQ     (1e9 / PLUTO_SPEED_NS)
#define TMAX           ((1<<5)-1)

#define W 10
#define F 11
#define MODULO ((1<<(W+F))-1)
#define MASK ((1<<(W+F))-1)
#define MAXDELTA (MASK/2)

typedef struct {
	int64_t last_count[4];
	int64_t reset_count[4];
	double old_position_cmd[4];
	double old_velocity_cmd[4];
} internal;

#define ONE (1<<F)
#define MAX_STEP_RATE ((1<<F)-1)
#define RPM_FREQ 19000 //?
#define PLLD_FREQ 500e6

static uint32_t * initMapMem(int fd, uint32_t addr, uint32_t len)
{
    return (uint32_t *) mmap(0, len,
       PROT_READ|PROT_WRITE|PROT_EXEC,
       MAP_SHARED|MAP_LOCKED,
       fd, addr);
}

int gpioInitialise(void){
   int fd;

   gpioHardwareRevision(); /* sets piModel, needed for peripherals address */

   fd = open("/dev/mem", O_RDWR | O_SYNC) ;

   if (fd < 0)
   {
      fprintf(stderr,
         "This program needs root privileges.  Try using sudo\n");
      return -1;
   }

   gpioReg  = initMapMem(fd, GPIO_BASE, GPIO_LEN);
   systReg  = initMapMem(fd, SYST_BASE, SYST_LEN);
   clkReg   = initMapMem(fd, CLK_BASE,  CLK_LEN);

   close(fd);

   if ((gpioReg == MAP_FAILED) ||
       (systReg == MAP_FAILED) ||
       (clkReg == MAP_FAILED))
   {
      fprintf(stderr,
         "Bad, mmap failed\n");
      return -1;
   }
   return 0;
}

int gpioInitialise(void){
   int fd;

   gpioHardwareRevision(); /* sets piModel, needed for peripherals address */
   fd = open("/dev/mem", O_RDWR | O_SYNC) ;
   if (fd < 0){
      //fprintf(stderr,"This program needs root privileges.  Try using sudo\n");
      return -1;
   }

   gpioReg  = initMapMem(fd, GPIO_BASE, GPIO_LEN);
   systReg  = initMapMem(fd, SYST_BASE, SYST_LEN);
   clkReg   = initMapMem(fd, CLK_BASE,  CLK_LEN);

   close(fd);

   if ((gpioReg == MAP_FAILED) ||
       (systReg == MAP_FAILED) ||
       (clkReg == MAP_FAILED)){
      //fprintf(stderr,  "Bad, mmap failed\n");
      return -1;
   }
   return 0;
}

static int initClock(int clock, int source, int divI, int divF, int MASH)
{
   int ctl[] = {CLK_GP0_CTL, CLK_GP2_CTL};
   int div[] = {CLK_GP0_DIV, CLK_GP2_DIV};
   int src[CLK_SRCS] =
      {CLK_CTL_SRC_PLLD,
       CLK_CTL_SRC_OSC,
       CLK_CTL_SRC_HDMI,
       CLK_CTL_SRC_PLLC};

   int clkCtl, clkDiv, clkSrc;
   uint32_t setting;

   if ((clock  < 0) || (clock  > 1))    return -1;
   if ((source < 0) || (source > 3 ))   return -2;
   if ((divI   < 2) || (divI   > 4095)) return -3;
   if ((divF   < 0) || (divF   > 4095)) return -4;
   if ((MASH   < 0) || (MASH   > 3))    return -5;

   clkCtl = ctl[clock];
   clkDiv = div[clock];
   clkSrc = src[source];

   clkReg[clkCtl] = CLK_PASSWD | CLK_CTL_KILL;

   /* wait for clock to stop */

   while (clkReg[clkCtl] & CLK_CTL_BUSY)
   {
      usleep(10);
   }

   clkReg[clkDiv] =
      (CLK_PASSWD | CLK_DIV_DIVI(divI) | CLK_DIV_DIVF(divF));

   usleep(10);

   clkReg[clkCtl] =
      (CLK_PASSWD | CLK_CTL_MASH(MASH) | CLK_CTL_SRC(clkSrc));

   usleep(10);

   clkReg[clkCtl] |= (CLK_PASSWD | CLK_CTL_ENAB);
}

int set_clk(double freq){//xx.ffMhz
   double div, f;
   char *clocks[CLK_SRCS]={"PLLD", " OSC", "HDMI", "PLLC"};
   int divI, divF;

  freq *= 1000.0;
  if ((freq < 4687.5) || (freq > PLLD_FREQ)) {return(-1);}

  div = PLLD_FREQ / freq;
  divI = div;
  divF = (div-divI) * 4096;

//  printf("%s: %4d %4d ", clocks[0], divI, divF);
  if ((divI<2) || (divI>4095)){
    //printf("ILLEGAL\n");
    return -1;
  }else{
    div = divI + (divF / 4096);
    f = PLLD_FREQ/div;
    //printf("%7.2f MHz\n", f/1000000.0);
  }

  if (gpioInitialise() < 0)
		return -1;
  initClock(0, 0, divI, divF, 0);
  gpioSetMode(4, PI_ALT0);
  return 0;
}

void gpioSetMode(unsigned gpio, unsigned mode)
{
   int reg, shift;

   reg   =  gpio/10;
   shift = (gpio%10) * 3;

   gpioReg[reg] = (gpioReg[reg] & ~(7<<shift)) | (mode<<shift);
}

EXTRA_SETUP() {
  if(set_clk(40.0)<0){
		rtapi_print_msg(RTAPI_MSG_ERR,
		        "HAL_rpi_spi_cpld: ERROR: cannot set clk\n");
		return -1;
  }
  fd=open("/dev/spidev1.2", O_RDWR);
  if(fd<0){
		rtapi_print_msg(RTAPI_MSG_ERR,
		        "HAL_rpi_spi_cpld: ERROR: cannot open spi\n");
		return -1;
  }
  spi_mode = 0;
  spi_bits = 8;
// SPICLK = 250 MHz/6 ~5Mbit
  spi_speed = 5000000;
  ioctl(fd, SPI_IOC_WR_MODE, &spi_mode);
  ioctl(fd, SPI_IOC_RD_MODE, &spi_mode);
  ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &spi_bits);
  ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, &spi_bits);
  ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &spi_speed);
  ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, &spi_speed);
	return 0;
}

EXTRA_CLEANUP() {
  close(fd);
}

int spi_transfer32(int fd, volatile __u32 *tx, volatile __u32 *rx){
	struct spi_ioc_transfer tr = {
		.tx_buf = (unsigned long)tx,
		.rx_buf = (unsigned long)rx,
		.len = SPI_BUFFER_SIZE,
		.delay_usecs = spi_delay,
		.speed_hz = spi_speed,
		.bits_per_word = spi_bits,
	};
	return ioctl(fd, SPI_IOC_MESSAGE(1), &tr);
}

FUNCTION(spitest) {
	char *buf;
	int i;
	__u32 spidata;
	
	for (i=0; i<BUFSIZE; i++) {
		txBuf[i] = i;
	}
	
	spi_transfer32(fd, txBuf, rxBuf);	
	for (i=5; i<BUFSIZE; i++) {
		spidata = rxBuf[i];
	}
}
	
FUNCTION(transfer) {
	char *buf;
	__u16 * tbuf;
	
	int i;
	__u32 spidata;
	
	int r = 0;
	int stepspace_ticks = stepgen_stepspace/PLUTO_SPEED_NS;
	int steplen_ticks = stepgen_steplen/PLUTO_SPEED_NS;
	int dirtime_ticks = stepgen_dirtime/PLUTO_SPEED_NS;
	int rate, maxrate = MAX_STEP_RATE;
	double fmax;

	if(steplen_ticks > TMAX) {
		steplen_ticks = TMAX;
		rtapi_print_msg(RTAPI_MSG_ERR,
				"Requested step length %dns decreased to %dns "
				"due to hardware limitations\n",
				stepgen_steplen, TMAX * PLUTO_SPEED_NS);
		stepgen_steplen = TMAX * PLUTO_SPEED_NS;
	}

	if(dirtime_ticks > TMAX) {
		dirtime_ticks = TMAX;
		rtapi_print_msg(RTAPI_MSG_ERR,
				"Requested direction change time %dns decreased to %dns "
				"due to hardware limitations\n",
				stepgen_dirtime, TMAX * PLUTO_SPEED_NS);
		stepgen_dirtime = TMAX * PLUTO_SPEED_NS;
	}

	// Speed limits come from several sources
	// First limit: step waveform timings
	fmax = 1.0 / PLUTO_SPEED / (2 + steplen_ticks + stepspace_ticks);
	// Second limit: highest speed command
	if(fmax > PLUTO_FREQ / (2<<speedrange))
			fmax = PLUTO_SPEED * (2<<speedrange);
	// Third limit: max sign-extenable counts per period
	if(fmax > MAXDELTA / fperiod / (1<<speedrange))
			fmax = MAXDELTA / fperiod / (1<<speedrange);

	//if(communication_error) return;
	
	tbuf = (__u16 *)txBuf;
	for(i=0; i<4; i++) {
		double new_position_cmd = stepgen_position_cmd(i);
		double v = new_position_cmd - data.old_position_cmd[i];
		double est_err = stepgen_position_fb(i) + data.old_velocity_cmd[i] * fperiod - new_position_cmd;
		double actual_max;
		double scale_abs = abs(stepgen_scale(i));

		v = v - debug_2 * est_err / fperiod;
		if(v > 0) v = v + .5/scale_abs;
		else if(v < 0) v = v - .5/scale_abs;

		data.old_position_cmd[i] = new_position_cmd;
		data.old_velocity_cmd[i] = v;
		actual_max = fmax / scale_abs;
		if(stepgen_maxvel(i) < 0) stepgen_maxvel(i) = -stepgen_maxvel(i);
		if(stepgen_maxvel(i) != 0 && stepgen_maxvel(i) > actual_max) {
			static int message_printed[4] = {0,0,0,0};
			if(!message_printed[i]) {
				rtapi_print_msg(RTAPI_MSG_ERR,
						"Requested step rate %dHz decreased to %dHz "
						"due to hardware or timing limitations\n",
						(int)(stepgen_maxvel(i) * scale_abs),
						(int)(fmax));
				message_printed[i] = 1;
			}
			stepgen_maxvel(i) = actual_max;
		}

		if(stepgen_maxvel(i) == 0) {
			if(v < -actual_max) v = -actual_max;
			if(v > actual_max) v = actual_max;
		}else {
			if(v < -stepgen_maxvel(i)) v = -stepgen_maxvel(i);
			if(v > stepgen_maxvel(i)) v = stepgen_maxvel(i);
		}
		rate = v*stepgen_scale(i)*ONE*PLUTO_SPEED/(1<<speedrange);

		if(rate > maxrate) rate = maxrate;
		if(rate < -maxrate) rate = -maxrate;

		if(!stepgen_enable(i)) rate = 0;
		//if(i == 0) debug_1 = rate;
		//if(!i%2)
		//	txBuf[i%2] = 0;
		//txBuf[i%2] |= rate<<(16*(i%2));
		tbuf[i] = rate;
	}

	r = 0;
	for(i=0; i<14; i++) {
		if(!dout(i) ^ !dout_invert(i)) r |= (1<<i);
	}
	txBuf[2] = r;
	r=0;
	r = steplen_ticks | (dirtime_ticks << 8);
	//r = steplen_ticks+stepspace_ticks | (dirtime_ticks << 8);
	if (stepgen_step_polarity) {
			r |= 0x8000;
	}else r &= 0x7FFF;
	txBuf[2] |= r<<16;
	
	txBuf[3]=(__u32)pwm_out;
	for (i=4; i<BUFSIZE; i++) { //fake
		txBuf[i] = i;
	}
	
	spi_transfer32(fd, txBuf, rxBuf);
  	
	for(i=0; i<4; i++) {
		int64_t count;
		double fcount;
		int newlow;
		int reset;
		
		spidata = rxBuf[i];
		
		reset = stepgen_reset(i);
		newlow = spidata & MASK;
		count = extend(data.last_count[i], newlow, W+F);
		stepgen_velocity_fb(i) = (count-data.last_count[i])/stepgen_scale(i)/fperiod/(1<<F);
		data.last_count[i] = count;
		if(reset) data.reset_count[i] = count;
		fcount = (count-data.reset_count[i])*1.0/(1<<F);
		stepgen_counts(i) = fcount;
		stepgen_position_fb(i) = fcount/stepgen_scale(i);


		if(i == 0) {
		//		debug_0 = spidata;
			debug_1 = newlow;
		}
	}

	spidata = rxBuf[4];
	debug_0 = spidata; //din
	//debug_1 = spidata;

	for(i=0; i< 16; i++) {
		int b = spidata & (1<<i);
		din(i) = !!b;
		din_not(i) = !b;
	}

	spindle_rpm=(RPM_FREQ*60)/(spidata>>16);
  
	for (i=5; i<BUFSIZE; i++) { //clear buf?
		spidata = rxBuf[i];
	}
}
/*
platform_t check_platform(void)
{
	FILE *fp;
	char buf[2048];
	size_t fsize;

	fp = fopen("/proc/cpuinfo", "r");
	fsize = fread(buf, 1, sizeof(buf), fp);
	fclose(fp);
	
	if (fsize == 0 || fsize == sizeof(buf))
		return 0;

	// NUL terminate the buffer
	buf[fsize] = '\0';

	if (NULL != strstr(buf, "BCM2708"))
		return RPI;
	else if (NULL != strstr(buf, "BCM2709"))
		return RPI_2;
	else
		return UNSUPPORTED;
}
*/